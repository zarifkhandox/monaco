<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
	<script>
		(function (root, name, factory) {
  'use strict';
  var objectTypes = {
      'function': true,
      'object': true
    },
    freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
    freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
    freeGlobal = freeExports && freeModule && typeof global === 'object' && global,
    moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
  if (freeGlobal && (freeGlobal.global === freeGlobal ||
      freeGlobal.window === freeGlobal ||
      freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }
  if (typeof define === 'function' &&
    typeof define.amd === 'object' &&
    define.amd) {
    define(['exports'], factory);
    if (freeExports && moduleExports) factory(freeModule.exports);
  } else
  if (freeExports && freeModule) {
    if (moduleExports) factory(freeModule.exports);
    else factory(freeExports);
  } else {
    factory((root[name] = {}));
  }
}(this, 'luaparse', function (exports) {
  'use strict';

  exports.version = '0.2.1';

  var input, options, length, features, encodingMode;
  var defaultOptions = exports.defaultOptions = {
    wait: false,
    comments: true,
    scope: false,
    locations: false,
    ranges: false,
    onCreateNode: null,
    onCreateScope: null,
    onDestroyScope: null,
    onLocalDeclaration: null,
    luaVersion: '5.1',
    encodingMode: 'none'
  };

  function encodeUTF8(codepoint, highMask) {
    highMask = highMask || 0;

    if (codepoint < 0x80) {
      return String.fromCharCode(codepoint);
    } else if (codepoint < 0x800) {
      return String.fromCharCode(
        highMask | 0xc0 | (codepoint >> 6),
        highMask | 0x80 | (codepoint & 0x3f)
      );
    } else if (codepoint < 0x10000) {
      return String.fromCharCode(
        highMask | 0xe0 | (codepoint >> 12),
        highMask | 0x80 | ((codepoint >> 6) & 0x3f),
        highMask | 0x80 | (codepoint & 0x3f)
      );
    } else
    if (codepoint < 0x110000) {
      return String.fromCharCode(
        highMask | 0xf0 | (codepoint >> 18),
        highMask | 0x80 | ((codepoint >> 12) & 0x3f),
        highMask | 0x80 | ((codepoint >> 6) & 0x3f),
        highMask | 0x80 | (codepoint & 0x3f)
      );
    } else {
      return null;
    }
  }

  function toHex(num, digits) {
    var result = num.toString(16);
    while (result.length < digits)
      result = '0' + result;
    return result;
  }

  function checkChars(rx) {
    return function (s) {
      var m = rx.exec(s);
      if (!m)
        return s;
      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());
    };
  }

  var encodingModes = {
    'pseudo-latin1': {
      fixup: checkChars(/[^\x00-\xff]/),
      encodeByte: function (value) {
        if (value === null)
          return '';
        return String.fromCharCode(value);
      },
      encodeUTF8: function (codepoint) {
        return encodeUTF8(codepoint);
      },
    },
    'x-user-defined': {
      fixup: checkChars(/[^\x00-\x7f\uf780-\uf7ff]/),
      encodeByte: function (value) {
        if (value === null)
          return '';
        if (value >= 0x80)
          return String.fromCharCode(value | 0xf700);
        return String.fromCharCode(value);
      },
      encodeUTF8: function (codepoint) {
        return encodeUTF8(codepoint, 0xf700);
      }
    },
    'none': {
      discardStrings: true,
      fixup: function (s) {
        return s;
      },
      encodeByte: function (value) {
        return '';
      },
      encodeUTF8: function (codepoint) {
        return '';
      }
    }
  };

  var EOF = 1,
    StringLiteral = 2,
    Keyword = 4,
    Identifier = 8,
    NumericLiteral = 16,
    Punctuator = 32,
    BooleanLiteral = 64,
    NilLiteral = 128,
    VarargLiteral = 256;

  exports.tokenTypes = {
    EOF: EOF,
    StringLiteral: StringLiteral,
    Keyword: Keyword,
    Identifier: Identifier,
    NumericLiteral: NumericLiteral,
    Punctuator: Punctuator,
    BooleanLiteral: BooleanLiteral,
    NilLiteral: NilLiteral,
    VarargLiteral: VarargLiteral
  };

  var errors = exports.errors = {
    unexpected: 'unexpected %1 \'%2\' near \'%3\'',
    unexpectedEOF: 'unexpected symbol near \'<eof>\'',
    expected: '\'%1\' expected near \'%2\'',
    expectedToken: '%1 expected near \'%2\'',
    unfinishedString: 'unfinished string near \'%1\'',
    malformedNumber: 'malformed number near \'%1\'',
    decimalEscapeTooLarge: 'decimal escape too large near \'%1\'',
    invalidEscape: 'invalid escape sequence near \'%1\'',
    hexadecimalDigitExpected: 'hexadecimal digit expected near \'%1\'',
    braceExpected: 'missing \'%1\' near \'%2\'',
    tooLargeCodepoint: 'UTF-8 value too large near \'%1\'',
    unfinishedLongString: 'unfinished long string (starting at line %1) near \'%2\'',
    unfinishedLongComment: 'unfinished long comment (starting at line %1) near \'%2\'',
    ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \'%1\'',
    noLoopToBreak: 'no loop to break near \'%1\'',
    labelAlreadyDefined: 'label \'%1\' already defined on line %2',
    labelNotVisible: 'no visible label \'%1\' for <goto>',
    gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \'%2\'',
    cannotUseVararg: 'cannot use \'...\' outside a vararg function near \'%1\'',
    invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'
  };

  var ast = exports.ast = {
    labelStatement: function (label) {
        return {
          type: 'LabelStatement',
          label: label
        };
      },
    breakStatement: function () {
        return {
          type: 'BreakStatement'
        };
      },
    gotoStatement: function (label) {
        return {
          type: 'GotoStatement',
          label: label
        };
      },
    returnStatement: function (args) {
        return {
          type: 'ReturnStatement',
          'arguments': args
        };
      },
    ifStatement: function (clauses) {
      return {
        type: 'IfStatement',
        clauses: clauses
      };
    },
    ifClause: function (condition, body) {
      return {
        type: 'IfClause',
        condition: condition,
        body: body
      };
    },
    elseifClause: function (condition, body) {
      return {
        type: 'ElseifClause',
        condition: condition,
        body: body
      };
    },
    elseClause: function (body) {
        return {
          type: 'ElseClause',
          body: body
        };
      },
    whileStatement: function (condition, body) {
        return {
          type: 'WhileStatement',
          condition: condition,
          body: body
        };
      },
    doStatement: function (body) {
        return {
          type: 'DoStatement',
          body: body
        };
      },
    repeatStatement: function (condition, body) {
        return {
          type: 'RepeatStatement',
          condition: condition,
          body: body
        };
      },
    localStatement: function (variables, init) {
        return {
          type: 'LocalStatement',
          variables: variables,
          init: init
        };
      },
    assignmentStatement: function (variables, init) {
        return {
          type: 'AssignmentStatement',
          variables: variables,
          init: init
        };
      },
    callStatement: function (expression) {
        return {
          type: 'CallStatement',
          expression: expression
        };
      },
    functionStatement: function (identifier, parameters, isLocal, body) {
        return {
          type: 'FunctionDeclaration',
          identifier: identifier,
          isLocal: isLocal,
          parameters: parameters,
          body: body
        };
      },
    forNumericStatement: function (variable, start, end, step, body) {
        return {
          type: 'ForNumericStatement',
          variable: variable,
          start: start,
          end: end,
          step: step,
          body: body
        };
      },
    forGenericStatement: function (variables, iterators, body) {
        return {
          type: 'ForGenericStatement',
          variables: variables,
          iterators: iterators,
          body: body
        };
      },
    chunk: function (body) {
        return {
          type: 'Chunk',
          body: body
        };
      },
    identifier: function (name) {
        return {
          type: 'Identifier',
          name: name
        };
      },
    literal: function (type, value, raw) {
        type = (type === StringLiteral) ? 'StringLiteral' :
          (type === NumericLiteral) ? 'NumericLiteral' :
          (type === BooleanLiteral) ? 'BooleanLiteral' :
          (type === NilLiteral) ? 'NilLiteral' :
          'VarargLiteral';

        return {
          type: type,
          value: value,
          raw: raw
        };
      },
    tableKey: function (key, value) {
      return {
        type: 'TableKey',
        key: key,
        value: value
      };
    },
    tableKeyString: function (key, value) {
      return {
        type: 'TableKeyString',
        key: key,
        value: value
      };
    },
    tableValue: function (value) {
        return {
          type: 'TableValue',
          value: value
        };
      },
    tableConstructorExpression: function (fields) {
      return {
        type: 'TableConstructorExpression',
        fields: fields
      };
    },
    binaryExpression: function (operator, left, right) {
      var type = ('and' === operator || 'or' === operator) ?
        'LogicalExpression' :
        'BinaryExpression';

      return {
        type: type,
        operator: operator,
        left: left,
        right: right
      };
    },
    unaryExpression: function (operator, argument) {
      return {
        type: 'UnaryExpression',
        operator: operator,
        argument: argument
      };
    },
    memberExpression: function (base, indexer, identifier) {
        return {
          type: 'MemberExpression',
          indexer: indexer,
          identifier: identifier,
          base: base
        };
      },
    indexExpression: function (base, index) {
        return {
          type: 'IndexExpression',
          base: base,
          index: index
        };
      },
    callExpression: function (base, args) {
        return {
          type: 'CallExpression',
          base: base,
          'arguments': args
        };
      },
    tableCallExpression: function (base, args) {
        return {
          type: 'TableCallExpression',
          base: base,
          'arguments': args
        };
      },
    stringCallExpression: function (base, argument) {
        return {
          type: 'StringCallExpression',
          base: base,
          argument: argument
        };
      },
    comment: function (value, raw) {
      return {
        type: 'Comment',
        value: value,
        raw: raw
      };
    }
  };

  function finishNode(node) {
    if (trackLocations) {
      var location = locations.pop();
      location.complete();
      location.bless(node);
    }
    if (options.onCreateNode) options.onCreateNode(node);
    return node;
  }

  var slice = Array.prototype.slice,
    toString = Object.prototype.toString;

  var indexOf = function (array, element) {
    for (var i = 0, length = array.length; i < length; ++i) {
      if (array[i] === element) return i;
    }
    return -1;
  };
  if (Array.prototype.indexOf)
    indexOf = function (array, element) {
      return array.indexOf(element);
    };

  function indexOfObject(array, property, element) {
    for (var i = 0, length = array.length; i < length; ++i) {
      if (array[i][property] === element) return i;
    }
    return -1;
  }

  function sprintf(format) {
    var args = slice.call(arguments, 1);
    format = format.replace(/%(\d)/g, function (match, index) {
      return '' + args[index - 1] || '';
    });
    return format;
  }

  var assign = function (dest) {
    var args = slice.call(arguments, 1),
      src, prop;

    for (var i = 0, length = args.length; i < length; ++i) {
      src = args[i];
      for (prop in src)
        if (Object.prototype.hasOwnProperty.call(src, prop)) {
          dest[prop] = src[prop];
        }
    }

    return dest;
  };
  if (Object.assign)
    assign = Object.assign;

  function fixupError(e) {
    if (!Object.create)
      return e;
    return Object.create(e, {
      'line': {
        'writable': true,
        value: e.line
      },
      'index': {
        'writable': true,
        value: e.index
      },
      'column': {
        'writable': true,
        value: e.column
      }
    });
  }

  function raise(token) {
    var message = sprintf.apply(null, slice.call(arguments, 1)),
      error, col;

    if (token === null || typeof token.line === 'undefined') {
      col = index - lineStart + 1;
      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));
      error.index = index;
      error.line = line;
      error.column = col;
    } else {
      col = token.range[0] - token.lineStart;
      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));
      error.line = token.line;
      error.index = token.range[0];
      error.column = col;
    }
    throw error;
  }

  function tokenValue(token) {
    var raw = input.slice(token.range[0], token.range[1]);
    if (raw)
      return raw;
    return token.value;
  }

  function raiseUnexpectedToken(type, token) {
    raise(token, errors.expectedToken, type, tokenValue(token));
  }

  function unexpected(found) {
    var near = tokenValue(lookahead);
    if ('undefined' !== typeof found.type) {
      var type;
      switch (found.type) {
        case StringLiteral:
          type = 'string';
          break;
        case Keyword:
          type = 'keyword';
          break;
        case Identifier:
          type = 'identifier';
          break;
        case NumericLiteral:
          type = 'number';
          break;
        case Punctuator:
          type = 'symbol';
          break;
        case BooleanLiteral:
          type = 'boolean';
          break;
        case NilLiteral:
          return raise(found, errors.unexpected, 'symbol', 'nil', near);
        case EOF:
          return raise(found, errors.unexpectedEOF);
      }
      return raise(found, errors.unexpected, type, tokenValue(found), near);
    }
    return raise(found, errors.unexpected, 'symbol', found, near);
  }

  var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;

  exports.lex = lex;

  function lex() {
    skipWhiteSpace();
    while (45 === input.charCodeAt(index) &&
      45 === input.charCodeAt(index + 1)) {
      scanComment();
      skipWhiteSpace();
    }
    if (index >= length) return {
      type: EOF,
      value: '<eof>',
      line: line,
      lineStart: lineStart,
      range: [index, index]
    };

    var charCode = input.charCodeAt(index),
      next = input.charCodeAt(index + 1);
    tokenStart = index;
    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();

    switch (charCode) {
      case 39:
      case 34:
        return scanStringLiteral();
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return scanNumericLiteral();

      case 46:
        if (isDecDigit(next)) return scanNumericLiteral();
        if (46 === next) {
          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();
          return scanPunctuator('..');
        }
        return scanPunctuator('.');

      case 61:
        if (61 === next) return scanPunctuator('==');
        return scanPunctuator('=');

      case 62:
        if (features.bitwiseOperators)
          if (62 === next) return scanPunctuator('>>');
        if (61 === next) return scanPunctuator('>=');
        return scanPunctuator('>');

      case 60:
        if (features.bitwiseOperators)
          if (60 === next) return scanPunctuator('<<');
        if (61 === next) return scanPunctuator('<=');
        return scanPunctuator('<');

      case 126:
        if (61 === next) return scanPunctuator('~=');
        if (!features.bitwiseOperators)
          break;
        return scanPunctuator('~');

      case 58:
        if (features.labels)
          if (58 === next) return scanPunctuator('::');
        return scanPunctuator(':');

      case 91:
        if (91 === next || 61 === next) return scanLongStringLiteral();
        return scanPunctuator('[');

      case 47:
        if (features.integerDivision)
          if (47 === next) return scanPunctuator('//');
        return scanPunctuator('/');

      case 38:
      case 124:
        if (!features.bitwiseOperators)
          break;
      case 42:
      case 94:
      case 37:
      case 44:
      case 123:
      case 125:
      case 93:
      case 40:
      case 41:
      case 59:
      case 35:
      case 45:
      case 43:
        return scanPunctuator(input.charAt(index));
    }

    return unexpected(input.charAt(index));
  }

  function consumeEOL() {
    var charCode = input.charCodeAt(index),
      peekCharCode = input.charCodeAt(index + 1);

    if (isLineTerminator(charCode)) {
      if (10 === charCode && 13 === peekCharCode) ++index;
      if (13 === charCode && 10 === peekCharCode) ++index;
      ++line;
      lineStart = ++index;

      return true;
    }
    return false;
  }

  function skipWhiteSpace() {
    while (index < length) {
      var charCode = input.charCodeAt(index);
      if (isWhiteSpace(charCode)) {
        ++index;
      } else if (!consumeEOL()) {
        break;
      }
    }
  }

  function scanIdentifierOrKeyword() {
    var value, type;
    while (isIdentifierPart(input.charCodeAt(++index)));
    value = encodingMode.fixup(input.slice(tokenStart, index));
    if (isKeyword(value)) {
      type = Keyword;
    } else if ('true' === value || 'false' === value) {
      type = BooleanLiteral;
      value = ('true' === value);
    } else if ('nil' === value) {
      type = NilLiteral;
      value = null;
    } else {
      type = Identifier;
    }

    return {
      type: type,
      value: value,
      line: line,
      lineStart: lineStart,
      range: [tokenStart, index]
    };
  }

  function scanPunctuator(value) {
    index += value.length;
    return {
      type: Punctuator,
      value: value,
      line: line,
      lineStart: lineStart,
      range: [tokenStart, index]
    };
  }

  function scanVarargLiteral() {
    index += 3;
    return {
      type: VarargLiteral,
      value: '...',
      line: line,
      lineStart: lineStart,
      range: [tokenStart, index]
    };
  }

  function scanStringLiteral() {
    var delimiter = input.charCodeAt(index++),
      beginLine = line,
      beginLineStart = lineStart,
      stringStart = index,
      string = encodingMode.discardStrings ? null : '',
      charCode;

    for (;;) {
      charCode = input.charCodeAt(index++);
      if (delimiter === charCode) break;
      if (index > length || isLineTerminator(charCode)) {
        string += input.slice(stringStart, index - 1);
        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));
      }
      if (92 === charCode) {
        if (!encodingMode.discardStrings) {
          var beforeEscape = input.slice(stringStart, index - 1);
          string += encodingMode.fixup(beforeEscape);
        }
        var escapeValue = readEscapeSequence();
        if (!encodingMode.discardStrings)
          string += escapeValue;
        stringStart = index;
      }
    }
    if (!encodingMode.discardStrings) {
      string += encodingMode.encodeByte(null);
      string += encodingMode.fixup(input.slice(stringStart, index - 1));
    }

    return {
      type: StringLiteral,
      value: string,
      line: beginLine,
      lineStart: beginLineStart,
      lastLine: line,
      lastLineStart: lineStart,
      range: [tokenStart, index]
    };
  }

  function scanLongStringLiteral() {
    var beginLine = line,
      beginLineStart = lineStart,
      string = readLongString(false);
    if (false === string) raise(token, errors.expected, '[', tokenValue(token));

    return {
      type: StringLiteral,
      value: encodingMode.discardStrings ? null : encodingMode.fixup(string),
      line: beginLine,
      lineStart: beginLineStart,
      lastLine: line,
      lastLineStart: lineStart,
      range: [tokenStart, index]
    };
  }

  function scanNumericLiteral() {
    var character = input.charAt(index),
      next = input.charAt(index + 1);

    var value = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?
      readHexLiteral() : readDecLiteral();

    return {
      type: NumericLiteral,
      value: value,
      line: line,
      lineStart: lineStart,
      range: [tokenStart, index]
    };
  }

  function readHexLiteral() {
    var fraction = 0,
      binaryExponent = 1,
      binarySign = 1,
      digit, fractionStart, exponentStart, digitStart;

    digitStart = index += 2;
    if (!isHexDigit(input.charCodeAt(index)))
      raise(null, errors.malformedNumber, input.slice(tokenStart, index));

    while (isHexDigit(input.charCodeAt(index))) ++index;
    digit = parseInt(input.slice(digitStart, index), 16);
    if ('.' === input.charAt(index)) {
      fractionStart = ++index;

      while (isHexDigit(input.charCodeAt(index))) ++index;
      fraction = input.slice(fractionStart, index);
      fraction = (fractionStart === index) ? 0 :
        parseInt(fraction, 16) / Math.pow(16, index - fractionStart);
    }
    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {
      ++index;
      if ('+-'.indexOf(input.charAt(index++)) ? 1 : -1;

      exponentStart = index;
      if (!isDecDigit(input.charCodeAt(index)))
        raise(null, errors.malformedNumber, input.slice(tokenStart, index));

      while (isDecDigit(input.charCodeAt(index))) ++index;
      binaryExponent = input.slice(exponentStart, index);
      binaryExponent = Math.pow(2, binaryExponent * binarySign);
    }

    return (digit + fraction) * binaryExponent;
  }

  function readDecLiteral() {
    while (isDecDigit(input.charCodeAt(index))) ++index;
    if ('.' === input.charAt(index)) {
      ++index;
      while (isDecDigit(input.charCodeAt(index))) ++index;
    }
    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {
      ++index;
      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;
      if (!isDecDigit(input.charCodeAt(index)))
        raise(null, errors.malformedNumber, input.slice(tokenStart, index));

      while (isDecDigit(input.charCodeAt(index))) ++index;
    }

    return parseFloat(input.slice(tokenStart, index));
  }

  function readUnicodeEscapeSequence() {
    var sequenceStart = index++;

    if (input.charAt(index++) !== '{')
      raise(null, errors.braceExpected, '{', '\\' + input.slice(sequenceStart, index));
    if (!isHexDigit(input.charCodeAt(index)))
      raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));

    while (input.charCodeAt(index) === 0x30) ++index;
    var escStart = index;

    while (isHexDigit(input.charCodeAt(index))) {
      ++index;
      if (index - escStart > 6)
        raise(null, errors.tooLargeCodepoint, '\\' + input.slice(sequenceStart, index));
    }

    var b = input.charAt(index++);
    if (b !== '}') {
      if ((b === '"') || (b === "'"))
        raise(null, errors.braceExpected, '}', '\\' + input.slice(sequenceStart, index--));
      else
        raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));
    }

    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);
    var frag = '\\' + input.slice(sequenceStart, index);

    if (codepoint > 0x10ffff) {
      raise(null, errors.tooLargeCodepoint, frag);
    }

    return encodingMode.encodeUTF8(codepoint, frag);
  }

  function readEscapeSequence() {
    var sequenceStart = index;
    switch (input.charAt(index)) {
      case 'a':
        ++index;
        return '\x07';
      case 'n':
        ++index;
        return '\n';
      case 'r':
        ++index;
        return '\r';
      case 't':
        ++index;
        return '\t';
      case 'v':
        ++index;
        return '\x0b';
      case 'b':
        ++index;
        return '\b';
      case 'f':
        ++index;
        return '\f';
      case '\r':
      case '\n':
        consumeEOL();
        return '\n';

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart  255) {
          raise(null, errors.decimalEscapeTooLarge, '\\' + ddd);
        }
        return encodingMode.encodeByte(ddd, '\\' + frag);

      case 'z':
        if (features.skipWhitespaceEscape) {
          ++index;
          skipWhiteSpace();
          return '';
        }
        break;

      case 'x':
        if (features.hexEscapes) {
          if (isHexDigit(input.charCodeAt(index + 1)) &&
            isHexDigit(input.charCodeAt(index + 2))) {
            index += 3;
            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\' + input.slice(sequenceStart, index));
          }
          raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index + 2));
        }
        break;

      case 'u':
        if (features.unicodeEscapes)
          return readUnicodeEscapeSequence();
        break;

      case '\\':
      case '"':
      case "'":
        return input.charAt(index++);
    }

    if (features.strictEscapes)
      raise(null, errors.invalidEscape, '\\' + input.slice(sequenceStart, index + 1));
    return input.charAt(index++);
  }

  function scanComment() {
    tokenStart = index;
    index += 2;

    var character = input.charAt(index),
      content = '',
      isLong = false,
      commentStart = index,
      lineStartComment = lineStart,
      lineComment = line;

    if ('[' === character) {
      content = readLongString(true);
      if (false === content) content = character;
      else isLong = true;
    }
    if (!isLong) {
      while (index  0)
      throw new Error('Location tracking failed. This is most likely a bug in luaparse');

    return chunk;
  }

}));
	</script>

	<style type="text/css">
		html,
		body {
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
	</style>
	<meta charset="utf-8" />
	<title></title>
	<link rel="stylesheet" type="text/css" href="Gotham-Bold.otf" />
</head>

<body>
  <div class="editor-container">
      <div id="tabs-container" class="tabs-container"></div>
      <div id="container" style="width:100%;height:calc(100% - 35px);"></div>
  </div>
  <style>
      @font-face {
          font-family: 'Gotham';
          src: url('Gotham-Bold.otf') format('opentype');
          font-weight: bold;
      }
      .editor-container {
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
      }
      .tabs-container {
          background-color: #1F1F1F;
          display: flex;
          height: 35px;
          overflow-x: auto;
          border-bottom: 1px solid #333;
          gap: 0;
      }
      .tab {
          display: flex;
          align-items: center;
          padding: 0 15px;
          background-color: #1F1F1F;
          color: #969696;
          border-right: 1px solid #1F1F1F;
          min-width: 120px;
          max-width: 200px;
          position: relative;
          cursor: pointer;
          transition: background-color 0.2s, color 0.2s;
          user-select: none;
          font-family: 'Gotham', sans-serif;
      }
          .tab.active {
              background-color: #1F1F1F;
              color: #ffffff;
          }
      .tab-icon {
          width: 20px;
          height: 20px;
          margin-right: 8px;
          display: flex;
          align-items: center;
          justify-content: center; 
          position: relative; 
          top: 2px;
      }
      .tab-icon svg {
          width: 16px;
          height: 16px;
      }
      .tab-title {
          flex-grow: 1;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          font-size: 13px;
          font-family: 'Gotham', sans-serif;
      }
      .tab-title.editing {
          background: #3d3d3d;
          border: 1px solid #525252;
          padding: 2px 4px;
          border-radius: 3px;
          outline: none;
      }
      .tab-close {
          margin-left: 8px;
          opacity: 0.7;
          transition: opacity 0.2s;
          display: flex;
          align-items: center;
          justify-content: center;
          width: 16px;
          height: 16px;
          border-radius: 3px;
      }
      .tab-close:hover {
          opacity: 1;
          background-color: rgba(255,255,255,0.1);
      }
      .tab.new-tab {
          min-width: 10px;
          max-width: 10px;
          justify-content: center;
          background-color: transparent;
          border: none;
          margin-left: -2px;
      }
      .tab.new-tab:hover {
          background-color: rgba(255,255,255,0.1);
      }
      @keyframes tabAppear {
          from {
              opacity: 0;
              transform: translateY(-10px);
          }
          to {
              opacity: 1;
              transform: translateY(0);
          }
      }
      @keyframes tabRemove {
          to {
              opacity: 0;
              transform: translateX(-10px);
          }
      }
      .tab.new {
          animation: tabAppear 0.2s ease-out;
      }
      .tab.removing {
          animation: tabRemove 0.2s ease-out;
      }
  </style>
  <script src="vs/loader.js"></script>
  <script type="text/javascript">
      require.config({
          paths: {
              'vs': 'vs'
          }
      });

      let editor;
      let Proposals = [];
      let currentTab = null;
      let tabs = [];
      let tabCounter = 1; // Initialize tab counter

      const luaIcon = `<img src="luaicon.png" alt="Lua Icon" style="width: 20px; height: 20px;" />`;

        class Tab {
            constructor(title, content = '') {
                this.id = 'tab-' + Math.random().toString(36).substr(2, 9);
                this.title = title;
                this.content = content;
                this.element = null;
            }
        }

        function saveTabs() {
          const tabsData = tabs.map(tab => ({
        id: tab.id,
        title: tab.title,
        content: tab.content
    }));
    localStorage.setItem('editorTabs', JSON.stringify(tabsData));
}
function loadTabs() {
    const savedTabs = localStorage.getItem('editorTabs');
    if (savedTabs) {
        const tabsData = JSON.parse(savedTabs);
        tabsData.forEach(tabData => {
            addTab(tabData.title, tabData.content, tabData.id);
        });
    } else {
        addTab(`Script #${tabCounter++}`); // Use tabCounter for the first tab
    }
}

        function makeEditable(titleElement, tab) {
            titleElement.contentEditable = true;
            titleElement.classList.add('editing');
            titleElement.focus();
            
            const range = document.createRange();
            range.selectNodeContents(titleElement);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

            function finishEditing() {
                titleElement.contentEditable = false;
                titleElement.classList.remove('editing');
                const newTitle = titleElement.textContent.trim();
                if (newTitle) {
                    tab.title = newTitle;
                } else {
                    titleElement.textContent = tab.title;
                }
                saveTabs(); // Save tabs after editing title
            }

            titleElement.onblur = finishEditing;
            titleElement.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEditing();
                }
                if (e.key === 'Escape') {
                    titleElement.textContent = tab.title;
                    finishEditing();
                }
            };
        }

        function createTabElement(tab) {
            const tabElement = document.createElement('div');
            tabElement.className = 'tab new';
            tabElement.setAttribute('data-tab-id', tab.id);
            
            const iconElement = document.createElement('div');
            iconElement.className = 'tab-icon';
            iconElement.innerHTML = luaIcon;
            
            const titleElement = document.createElement('div');
            titleElement.className = 'tab-title';
            titleElement.textContent = tab.title;
            
            titleElement.ondblclick = (e) => {
                e.stopPropagation();
                makeEditable(titleElement, tab);
            };
            
            const closeButton = document.createElement('div');
            closeButton.className = 'tab-close';
            closeButton.innerHTML = '✕';
            closeButton.onclick = (e) => {
                e.stopPropagation();
                if (tabs.length > 1) {
                    removeTab(tab.id);
                }
            };
            
            tabElement.appendChild(iconElement);
            tabElement.appendChild(titleElement);
            tabElement.appendChild(closeButton);
            
            tabElement.onclick = () => switchTab(tab.id);
            
            return tabElement;
        }

        function createNewTabButton() {
            const newTabButton = document.createElement('div');
            newTabButton.className = 'tab new-tab';
            newTabButton.innerHTML = '+';
            newTabButton.onclick = () => {
                const newTab = addTab(`Script #${tabCounter++}`); //Increment and use tabCounter
            };
            return newTabButton;
        }

        function addTab(title, content = '', id = null) {
    const tab = new Tab(title, content);
    if (id) tab.id = id;
    tabs.push(tab);
    
    const tabsContainer = document.getElementById('tabs-container');
    const newTabButton = tabsContainer.querySelector('.new-tab');
    
    tab.element = createTabElement(tab);
    if (newTabButton) {
        tabsContainer.insertBefore(tab.element, newTabButton);
    } else {
        tabsContainer.appendChild(tab.element);
        tabsContainer.appendChild(createNewTabButton());
    }
    
    switchTab(tab.id);
    saveTabs();
    return tab;
}

function removeTab(tabId) {
    const tabIndex = tabs.findIndex(t => t.id === tabId);
    if (tabIndex === -1) return;
    
    if (tabs.length <= 1) return;
    
    const tab = tabs[tabIndex];
    tab.element.classList.add('removing');
    
    setTimeout(() => {
        tabs.splice(tabIndex, 1);
        tab.element.remove();
        
        if (currentTab === tabId) {
            switchTab(tabs[Math.min(tabIndex, tabs.length - 1)].id);
        }
        saveTabs();
    }, 200);
}
function switchTab(tabId) {
    const tab = tabs.find(t => t.id === tabId);
    if (!tab) return;
    
    tabs.forEach(t => {
        if (t.element) {
            t.element.classList.remove('active');
        }
    });
    
    if (currentTab !== tabId) {
        if (currentTab) {
            const oldTab = tabs.find(t => t.id === currentTab);
            if (oldTab) {
                oldTab.content = editor.getValue();
                saveTabs();
            }
        }
        
        editor.setValue(tab.content);
        tab.element.classList.add('active');
        currentTab = tabId;
    }
}

function setupAutosave() {
    let saveTimeout;
    editor.onDidChangeModelContent(() => {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
            if (currentTab) {
                const tab = tabs.find(t => t.id === currentTab);
                if (tab) {
                    tab.content = editor.getValue();
                    saveTabs();
                }
            }
        }, 1); 
    });
}


    var enableAntiSkid;
    var disableAntiSkid;
		var SetText;
		var ShowMinimap;
		var HideMinimap;
		var EnableAutoComplete;
		var DisableAutoComplete;
		var GetText;
		var AddIntellisense;
		var Refresh;
	


		require(['vs/editor/editor.main'], function () {
			function getDependencyProposals() {
				return Proposals;
			}

			monaco.languages.registerCompletionItemProvider('lua', {
				provideCompletionItems: function (model, position) {
					return getDependencyProposals();
				},
				triggerCharacters: ['.', ':', '"'],
			});

			
			monaco.editor.defineTheme('net-theme-dark', {
				base: 'vs-dark',
				inherit: true,
				colors: {
					"editor.background": '#161515', //ur background color
				},
				rules: [{
						token: 'global',
						foreground: '6699cc', // //FFFFFF
						fontStyle: "bold"
					},
					{
						token: 'keyword',
						foreground: 'cc99cc',
						fontStyle: "bold"
					},
					{
						token: 'comment',
						foreground: '999999'
					},
					{
						token: 'number',
						foreground: 'f99157'
					},
					{
						token: 'string',
						foreground: '99CC99'
					},
					{
						token: 'Method',
						foreground: 'ffa1dc'
					},
				]
			});

			editor = monaco.editor.create(document.getElementById('container'), {
				language: 'lua',
				theme: "net-theme-dark",
				acceptSuggestionOnEnter: "smart",
				cursorSmoothCaretAnimation: true,
				suggestOnTriggerCharacters: true,
				suggestSelection: "recentlyUsed",
				folding: true,
					dragAndDrop: true,
					links: false,
					minimap: {
						enabled: false,
					},
					showFoldingControls: "always",
					smoothScrolling: true,
					stopRenderingLineAfter: 6500,
					cursorBlinking: "smooth",
					cursorSmoothCaretAnimation: true,
					foldingHighlight: false,
					fontLigatures: true,
					formatOnPaste: true,
					showDeprecated: true,
					suggest: {
						snippetsPreventQuickSuggestions: false,
					},
					padding: {
						top: 24,
					}
			});

      loadTabs();
      setupAutosave();

			EnableAutoComplete = function(){
				editor.updateOptions({
					suggestOnTriggerCharacters: true,
					acceptSuggestionOnEnter : "smart",
					wordBasedSuggestions : true
				});
			}

			DisableAutoComplete = function(){
				editor.updateOptions({
					suggestOnTriggerCharacters: false,
					acceptSuggestionOnEnter : "off",
					wordBasedSuggestions : false
				});
			}

			window.onresize = function () {
				editor.layout();
			};
   
			ShowMinimap = function () {
				editor.updateOptions({
					minimap: {
						enabled: true,
					}
				});
			}

			HideMinimap = function () {
				editor.updateOptions({
					minimap: {
						enabled: false,
					}
				});
			}

      function handleover()
      {
        document.body.style.filter = "blur(0px)"
      }
      function handleleave()
      {
        document.body.style.filter = "blur(5px)"
      }
      enableAntiSkid= function()
      {
        document.body.style.filter = "blur(5px)";
        document.body.addEventListener("mouseover",handleover);
        document.body.addEventListener("mouseleave",handleleave);
      }
      disableAntiSkid = function()
      {
        document.body.style.filter = "blur(0px)";
        document.body.removeEventListener("mouseover",handleover,false);
        document.body.removeEventListener("mouseleave",handleleave,false);
        
      }
      editor.onDidChangeModelContent(function (e) {
            try {
                luaparse.parse(editor.getValue());
                monaco.editor.setModelMarkers(editor.getModel(), 'luaparse', []);
            }
            catch(Err) {
                monaco.editor.setModelMarkers(editor.getModel(),'luaparse',[{
                     startLineNumber: Err.line,
                     startColumn: Err.column,
                     endLineNumber: Err.line,
                     endColumn: Err.column,
                     message: Err.message,
                     severity: 3
                }]);
            }
        });
			GetText = function () {
				return editor.getValue();
			}

			SetText = function (x) {
				editor.setValue(x);
			}

			AddIntellisense = function (l, k, d, i) {
				var t;
				switch (k) {
					case "Class":
						t = monaco.languages.CompletionItemKind.Class;
						break;
					case "Color":
						t = monaco.languages.CompletionItemKind.Color;
						break;
					case "Constructor":
						t = monaco.languages.CompletionItemKind.Constructor;
						break;
					case "Enum":
						t = monaco.languages.CompletionItemKind.Enum;
						break;
					case "Field":
						t = monaco.languages.CompletionItemKind.Field;
						break;
					case "File":
						t = monaco.languages.CompletionItemKind.File;
						break;
					case "Folder":
						t = monaco.languages.CompletionItemKind.Folder;
						break;
					case "Function":
						t = monaco.languages.CompletionItemKind.Function;
						break;
					case "Interface":
						t = monaco.languages.CompletionItemKind.Interface;
						break;
					case "Keyword":
						t = monaco.languages.CompletionItemKind.Keyword;
						break;
					case "Method":
						t = monaco.languages.CompletionItemKind.Method;
						break;
					case "Module":
						t = monaco.languages.CompletionItemKind.Module;
						break;
					case "Property":
						t = monaco.languages.CompletionItemKind.Property;
						break;
					case "Reference":
						t = monaco.languages.CompletionItemKind.Reference;
						break;
					case "Snippet":
						t = monaco.languages.CompletionItemKind.Snippet;
						break;
					case "Text":
						t = monaco.languages.CompletionItemKind.Text;
						break;
					case "Unit":
						t = monaco.languages.CompletionItemKind.Unit;
						break;
					case "Value":
						t = monaco.languages.CompletionItemKind.Value;
						break;
					case "Variable":
						t = monaco.languages.CompletionItemKind.Variable;
						break;
				}

				Proposals.push({
					label: l,
					kind: t,
					detail: d,
					insertText: i
				});
			}
			async function load() {
				var docs = await(await fetch('https://raw.githubusercontent.com/Insalad/monacoshit/refs/heads/main/blah')).json();

				for (var prop in docs) {
  					  for(var item in docs[prop])
					  {
						    const document = docs[prop][item];
							AddIntellisense(document.label, document.type, document.description, document.insert);
					  }
				}

				for (const Key of ["_G", "_VERSION", "Enum", "game", "plugin", "shared", "script", "workspace", "DebuggerManager", "elapsedTime", "LoadLibrary", "PluginManager", "settings", "tick", "time", "typeof", "UserSettings"])
                    AddIntellisense(Key, "Keyword", Key, Key);

				for (const Key of ["and", "break", "do", "else", "elseif", "end", "false", "for", "function", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while"])
                    AddIntellisense(Key, "Variable", Key, Key);

                for (const Key of ["math.abs", "math.acos", "math.asin", "math.atan", "math.atan2", "math.ceil", "math.cos", "math.cosh", "math.deg", "math.exp", "math.floor", "math.fmod", "math.frexp", "math.huge", "math.ldexp", "math.log", "math.max", "math.min", "math.modf", "math.pi", "math.pow", "math.rad", "math.random", "math.randomseed", "math.sin", "math.sinh", "math.sqrt", "math.tan", "math.tanh", "table.concat", "table.foreach", "table.foreachi", "table.sort", "table.insert", "table.remove", "Color3.new", "Instance.new", "BrickColor.new", "Vector3.new", "Vector2.new", "debug.gethook", "debug.getinfo", "debug.getlocal", "debug.getmetatable", "debug.getregistry", "debug.getupvalue", "debug.getuservalue", "debug.sethook", "debug.setlocal", "debug.setmetatable", "debug.setupvalue", "debug.setuservalue", "debug.traceback", "debug.upvalueid", "debug.upvaluejoin", "string.byte", "string.char", "string.dump", "string.find", "string.format", "string.gmatch", "string.gsub", "string.len", "string.lower", "string.match", "string.rep", "string.reverse", "string.sub", "string.upper", "coroutine.create", "coroutine.resume", "coroutine.running", "coroutine.status", "coroutine.wrap", "coroutine.yield"])
					AddIntellisense(Key, "Method", Key, Key);

				for (const Key of ["Drawing", "debug", "Instance", "Color3", "Vector3", "Vector2", "BrickColor", "math", "table", "string", "coroutine", "Humanoid", "ClickDetector", "LocalScript", "Model", "ModuleScript", "Mouse", "Part", "Player", "Script", "Tool", "RunService", "UserInputService", "Workspace"])
					AddIntellisense(Key, "Class", Key, Key);

				for (const Key of ["print", "warn", "wait", "info", "printidentity", "assert", "collectgarbage", "error", "getfenv", "getmetatable", "setmetatable", "ipairs", "loadfile", "loadstring", "newproxy", "next", "pairs", "pcall", "spawn", "rawequal", "rawget", "rawset", "select", "tonumber", "tostring", "type", "unpack", "xpcall", "delay", "stats", ":Remove()", ":BreakJoints()", ":GetChildren()", ":FindFirstChild()", ":FireServer()", ":InvokeServer()", ":ClearAllChildren()", ":Clone()", ":Destroy()", ":FindFirstAncestor()", ":FindFirstAncestorOfClass()", ":FindFirstAncestorWhichIsA()", ":FindFirstChildOfClass()", ":FindFirstChildWhichIsA()", ":GetDebugId()", ":GetDescendants()", ":GetFullName()", ":IsA()", ":GetPropertyChangedSignal()", ":IsAncestorOf()", ":IsDescendantOf()", ":WaitForChild()", ":Connect()", ":AncestryChanged()", ":Changed()", ":ChildAdded()", ":ChildRemoved()", ":DescendantAdded()", ":DescendantRemoving()", ":GetService()", ":GetObjects()", ":HttpGet()", ":Wait()"])
                    AddIntellisense(Key, "Function", Key, Key.includes(":") ? Key.substring(1, Key.length) : Key);

                for (const Key of ["Visible", "Color", "Transparency", "Thickness", "From", "To", "Text", "Size", "Center", "Outline", "OutlineColor", "Position", "TextBounds", "Font", "Data", "Rounding", "NumSides", "Radius", "Filled", "PointA", "PointB", "PointC", "PointD"])
					AddIntellisense(Key, "Property", "Property for Drawing Library", Key);

			}
			load();
			Refresh = function () {
				var text = GetText();
				SetText("");
				editor.trigger('keyboard', 'type', {
					text: text
				});
			}
		});
	</script>
</body>

</html>